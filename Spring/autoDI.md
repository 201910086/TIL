[스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)을 수강하며 정리한 내용이다.


### 의존관계 자동 주입

**의존관계 주입은 크게 4가지 방법이 있다**
1. 생성자 주입
2. 수정자 주입(setter 주입)
: setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해 의존관계 주입(선택, 변경)
3. 필드 주입
: 필드에 바로 주입하는 방법. 코드가 가장 간결하나, 외부에서의 변경이 불가능하다는 치명적 단점 존재
4. 일반 메서드 주입
: 일반 메서드를 통해 주입받는 방식이며 한번에 여러 필드를 주입받을 수 있음

#### 생성자 주입
* 이름 그대로 생성자를 통해 의존 관계를 주입
* 생성자 호출시점에 딱 1번만 호출
* 불변, 필수 의존관계에 사용
**생성자가 1개만 있으면 ```@Autowired``` 생략해도 가능**(스프링 빈에만 해당)


#### 옵션 처리
주입할 스프링 빈이 없어도 동작해야 할 때가 있는데, ```@Autowired``` 사용 시, ```required```의 옵션 기본값이 ```true```로 되어 있기에 자동 주입 대상이 없다면 오류가 발생한다.

따라서 자동 주입 대상을 옵션으로 처리하는 방법은 다음과 같이 세 가지가 있다.
1. ```@Autowired(required=false)```: 자동 주입 대상이 없으면 수정자 메서드 자체가 호출이 안됨
2. ```org.springframework.lang.@Nullable```: 자동 주입 대상이 없으면 null이 입력됨
3. ```Optional<>```: 자동 주입 대상이 없으면 ```Optional.empty```가 입력됨


### 생성자 주입 사용하기

생성자 주입만 따로 길게 적은 것처럼 다른 것들과 달리 주로 사용하는 것은 생성자 주입이다.
과거에는 수정자 주입과 필드 주입을 많이 사용했으나, 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장
**이유**
1. 불변
    - 대부분의 의존관계 주입은 한번 일어나면 종료시점까지 변경할 일이 거의 없다. 오히려 변경할 일이 있으면 안된다.
    - 수정자 주입 사용 시, setXxx 메서드를 public으로 열어놓아야 한다.
    - 누군가 실수로 변경할 수도 있고, 변경하면 안되는 메서드는 열어두지 않는 것이 좋다.
    - 생성자 주입은 1번만 호출되므로 불변하게 설계 가능하다.

2. 누락
    - 예를 들어 수정자 주입인 경우 : 실행은 되는데 막상 실행 결과는 의존관계 주입이 누락될 수 있다.
    - 생성자 주입 사용 시 주입 데이터가 누락된다면 -> **컴파일 오류**가 발생한다. 

3. final 키워드
    - 생성자 주입 사용 시 ```final``` 키워드 사용이 가능하다.(나머지 주입 방식은 생성자 이후에 호출되어 ```final``` 키워드 사용 불가)
    - -> 생성자에서 값이 설정되지 않는 오류가 발생하는 것을 컴파일 시점에서 막아줄 수 있다.
    - (컴파일 오류는 세상에서 가장 빠르고 좋은 오류!)

-->
* 생성자 주입 방식은 프레임워크에 의존하지 않고 순수 자바 언어의 특징을 잘 살리는 방법이기도 함
* 기본으로 생성자 주입 사용, 필수 값이 아닌 경우에는 수정자 주입 사용으로 옵션을 부여함으로써 생성자와 수정자 주입을 동시에 사용 가능
* 생성자 주입을 선택하되, 가끔 옵션이 필요한 경우 수정자 주입을 선택.


### 롬복과 최신 트렌드

* 롬복 라이브러리가 제공하는 ```@RequiredArgsConstructor``` 기능 사용 시, final이 붙은 필드를 모아서 생성자를 자동으로 만들어 준다.


#### 조회 빈이 2개 이상일 때의 문제

* ```@Autowired```는 타입으로 조회하는데, 타입으로 조회 시 선택된 빈이 2개 이상이면 문제 발생
* -> 하위 타입으로 지정할 수도 있으나 그건 DIP를 위배 + 유연성이 떨어진다.

**해결방법**
1. ```@Autowired``` 필드 명 매칭
: ```@Autowired```는 타입 매칭을 시도하고, 여러 빈이 있을 경우 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다. 필드 명을 빈 이름으로 변경 시 해결이 가능

2. ```@Qualifier``` -> @Qualifier끼리 매칭 -> 빈 이름 매칭
: 추가 구분자를 붙여주는 방법으로, 빈 이름을 변경하는 것은 아니다.
```
@Component
@Qualifier("mainDiscountPolicy")
public class RateDiscountPolicy implements DiscountPolicy {}
```
```
@Autowired
public OrderServiceImpl(MemberRepository memberRepository, 
@Qualifier("mainDiscountPolicy") DiscountPolicy
discountPolicy) {
    this.memberRepository = memberRepository;
    this.discountPolicy = discountPolicy;
}
```

3. ```@Primary``` 사용
: 우선순위를 정하는 방법으로 @Autowired시에 여러 빈이 매칭되면 ```@Primary```가 우선권을 가진다.

**@Primary, @Qualifier 활용**
메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 ```@Primary```를 적용하여 조회하는 곳에서 ```@Qualifier``` 지정 없이 편리하게 조회,
서브 데이터 커넥션 빈을 획득할 때는 ```@Qualifier```를 지정해서 명시적으로 획득하는 방식으로 활용.

* 둘중에는 ```@Qualifier```가 ```@Primary```보다 매우 상세하게 동작하므로 좁은 범위의 선택권이 우선순위가 높아 ```@Qualifier```가 우선권이 높다.


->
편리한 자동 기능을 기본으로 사용하되,
직접 등록하는 기술 지원 객체는 수동 등록.
다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보기.