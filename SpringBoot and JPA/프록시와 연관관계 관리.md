[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)을 수강하며 간단히 정리한 내용이다.

### 프록시와 연관관계 관리

#### 프록시
(지연 로딩과 즉시로딩을 이해하기 위해 먼저 프록시 개념 이해)
***
##### 프록시 기초
* em.find(): 데이터베이스를 통해서 실제 엔티티 객체 조회
* em.getReference(): 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체 조회
    * db에 쿼리가 안나가는데 조회가 됨. getReference()호출 시점에는 쿼리를 안함. 그런데 이 값이 실제 사용되는 시점에는 쿼리가 나감. 식별자로 넣는 id값은 안나가는데 그 이외의 것들(ex. username). 실제 getReference로 가져온 것을 프린트해보면 그냥 객체가 아니고 가짜 객체임.
##### 프록시 특징1
* 실제 클래스를 상속 받아서 만들어지는데 실제 클래스와 겉 모양은 같음
* 프록시 객체는 실제 객체의 참조(target)를 보관
* 프록시 객체 호출하면 프록시 객체는 실제 객체의 메소드 호출

##### 프록시 객체의 초기화
* 프록시 객체의 초기화가 진행되는 과정은 초기화 요청시 **영속성 컨텍스트**가 DB를 조회, 실제 entity를 생성하여 target.getXXX()를 반환

##### 프록시 특징2
* 프록시 객체는 처음 사용 시 한 번만 초기화가 됨
* 그리고 초기화를 할 때 프록시 객체가 실제 엔티티로 바뀌는 것은 아니며 프록시 객체를 통해 실제 엔티티에 접근이 가능한 것임
* 프록시 객체는 원본 엔티티를 상속받아 비교할 때는 ==이 아닌 instance of를 사용
* 영속성 컨텍스트에 찾는 엔티티가 이미 있으면 em.getReference()를 호출해도 실제 엔티티를 반환:
   * 1. 이미 1차캐시에 있는데 프록시로 가져올 이점이 없음. 1차캐시에 있는 걸 가져오는 것이 성능 최적화에도 나음
   * 2. jpa에서는 a==a하면 항상 true가 나와야 함. 실제든 프록시든 상관없이. 한 영속성 컨텍스트 안에서 가져온 것이면 항상 true를 반환해야 함. 프록시로 가져오면 ==비교하면 false로 나와버리기 때문에 true로 보장해주기 위해. 
   * 반대로 getReference먼저 한 객체하고 그 후에 find한 객체하면 find한 객체가 프록시로 반환됨. ==비교 보장. 
* 준영속 상태일 때: 프록시 초기화 시 문제 발생(org.hibernate.LazyInitializationException)

##### 프록시 확인
* 프록시 인스턴스의 초기화 여부 확인: PersistenceUnitUtil.isLoaded(Object entity)
* 프록시 클래스 확인 방법: entity.getClass().getName() 출력(..javasist.. or HibernateProxy…)
* 프록시 강제 초기화: org.hibernate.Hibernate.initialize(entity);
* 참고로 JPA 표준에는 강제 초기화가 없다. 강제호출: ```member.getName()```

#### 즉시 로딩과 지연 로딩
***
- 지연 로딩 LAZY를 사용해 프록시로 조회
- 가급적 지연로딩만 사용할 것
- 즉시 로딩 사용 시 JPQL에서 N+1 문제 발생
- ```@ManyToOne```, ```@OneToOne```은 기본값이 즉시로딩-> LAZY로 설정 필요
- 다른 건 기본값이 지연로딩

#### 영속성 전이: CASCADE
***
- 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 사용
- 예를 들면 부모 엔티티 저장 시 자식 엔티티도 같이 저장되도록.
- 그러나 연관관계 매핑과는 아무런 관련이 없으며, 엔티티를 영속화할 때 연관된 엔티티도 함께 영속화하는 편리함 제공 역할일 뿐임
- parent를 persist할 때 child도 같이 하려고 할 때. 만약 child가 parent에 단일 종속적(parent가 child의 단일 소유자)일 때는 사용하면 좋지만, child가 다른 객체에도 종속적이면 쓰면 x 
- 종류: ALL(모두 적용), PERSIST(영속), REMOVE(삭제) 등

#### 고아 객체
***
- 부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하게 하는 것이 ```고아 객체 제거```
- ```orphanRemoval = true```
- 주의: 참조하는 곳이 하나일 때 사용. 특정 엔티티가 개인 소유할 때 사용
- ```@OneToOne```, ```@OneToMany``` 만 가능
- 참고: 개념적으로 부모를 제거하면 자식은 고아가 된다. 따라서 고아 객체 제거 기능을 활성화 하면, 부모를 제거할 때 자식도 함께 제거된다. 이것은 CascadeType.REMOVE처럼 동작한다.

#### 영속성 전이 + 고아 객체, 생명주기
***
- ```CascadeType.ALL``` + ```orphanRemovel=true```
- 이 두 가지 옵션 모두 활성화할 시, 부모 엔티티를 통해 자식의 생명주기 관리 가능
- 도메인 주도 설계(DDD)의 Aggregate Root 개념 구현 시 유용