[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)을 수강하며 간단히 정리한 내용이다.

### 기본값 타입

#### JPA의 데이터 타입 분류
***
- 엔티티 타입
    * ```@Entity```로 정의하는 객체
    * 데이터 변해도 식별자로 추적 가능
- 값 타입
    * int, Integer, String과 같이 단순히 값으로 사용하는 자바 기본 타입이나 객체
    * 식별자 없고 값만 있어 추적 불가능
    * 기본값 타입(자바 기본 타입, 래퍼 클래스, String), 임베디드 타입, 컬렉션 값 타입으로 나뉨
- 기본값 타입
    * 생명주기를 엔티티에 의존(회원 삭제 시 이름, 나이 필드도 같이 삭제됨)
    * 값 타입은 공유하면 안됨(회원 이름 변경 시 다른 회원 이름도 같이 변경되면 안됨)

#### 임베디드 타입(복합 값 타입)
***
- 새로운 값 타입 정의
- 주로 기본 값 타입 모아 만들어서 복합 값 타입이라고도 함
- int, String과 같은 값 타입
- ```@Embeddable```: 값 타입을 정의하는 곳에 표시
- ```@Embedded```: 값 타입을 사용하는 곳에 표시
- 기본 생성자 필수
- 장점:
    * 재사용 및 높은 응집도
    * Period.isWork()와 같이 해당 값 타입만 사용하는 의미 있는 메소드 구현 가능
    * 임베디드 타입 포함한 모든 값 타입은 값 타입을 소유한 엔티티에 생명주기 의존
- 엔티티의 값일 뿐이므로 사용 전 후의 매핑하는 테이블은 같음

#### ```@AttributeOverride```: 속성 재정의
- 한 엔티티에 같은 값 타입을 여러 번 사용 시 -> 컬럼 명 중복
- ```@AttributeOverrides```, ```@AttributeOverride```를 사용해서 컬럼 명 속성을 재정의
```
@Embedded
@AttributeOverrides({
    @AttributeOveride(name="city",
        column=@Column("WORK_CITY")),
    @AttributeOveride(name="street",
        column=@Column("WORK_STREET")),
    @AttributeOveride(name="zipcode",
        column=@Column("WORK_ZIPCODE")),
})
```

### 값 타입과 불변 객체

#### 값 타입 공유 참조
***
- 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하는 것은 위험. 부작용 발생

#### 값 타입 복사
***
- 값 타입의 실제 인스턴스인 값 공유하는 것은 위험
- 대신 값(인스턴스) 복사해서 사용
```
Address newAddress = new Address("NewCity", address.getStreet(), address.getZipcode());
```

#### 객체 타입의 한계
***
- 항상 값을 복사해서 사용시 공유 참조로 인해 발생하는 부작용은 피할 수 있으나 임베디드 타입처럼 직접 정의한 값타입은 자바 기본 타입이 아닌 객체 타입.
- 따라서 객체 타입은 참조 값을 직접 대입하는 것을 막을 방법이 없어 객체의 공유 참조는 피할 수 없음

#### 불변 객체
***
- 객체 타입을 수정할 수 없게 부작용을 원천 차단시키기
- 값 타입은 불변 객체로 설계해야 함
- 불변 객체는 생성 시점 이후 수정이 불가능한 객체를 의미함
- 생성자로만 값을 설정하도록 구현하고 수정자를 만들지 않으면 됨(혹은 private으로 두거나)

### 값 타입의 비교
***
- 동일성(identity) 비교: 인스턴스의 참조 값 비교. ==
- 동등성(equivalence) 비고: 인스턴스의 값 비교. equals()
- 값 타입은 a.equals(b)로 동등성 비교를 해야 함
- 값 타입의 equals() 메소드를 적절하게 재정의하기(주로 모든 필드 사용)

### 값 타입 컬렉션
***
- 값 타입을 하나 이상 저장할 때 사용
- ```@ElementCollection```, ```@CollectionTable``` 사용
- 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없음
- 컬렉션을 저장하기 위한 별도의 테이블 필요
####
- 제약사항:
- 값 타입은 엔티티와 다르게 식별자 개념이 없으므로 변경하면 추적 불가능
- 값 타입 컬렉션에 변경 사항 발생 시 주인 엔티티와 연관된 모든 데이터 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장(간단하게 예를 들어 a1,a2 중 a2를 b2로 수정 시 a1, a2 모두 삭제하고 다시 a1, b2로 저장)
- 값 타입 컬렉션을 매핑하는 테이블은 모든 컬럼을 묶어서 기본 키를 구성해야 함: null 입력X, 중복 저장X
####
- 대안:
- 따라서 실무에서는 상황에 따라 값 타입 컬렉션 대신 일대다 관계를 고려
- 일대다 관계를 위한 엔티티 생성하고 여기에서 값 타입 사용
- 그리고 영속성 전이 + 고아 객체 제거 사용해서 값 타입 컬렉션처럼 사용