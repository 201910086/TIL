[자바 ORM 표준 JPA 프로그래밍 - 기본편](https://www.inflearn.com/course/ORM-JPA-Basic)을 수강하며 간단히 정리한 내용이다.

### 영속성 관리

JPA에서 가장 중요한 두가지는 
* 객체와 관계형 데이터베이스 매핑하기와
* **영속성 컨텍스트**이다.

#### 영속성 컨텍스트
***
- JPA를 이해하는데 가장 중요한 용어
- "엔티티를 영구 저장하는 환경"이라는 뜻
- EntityManager.persist(entity);
- 눈에 보이지 않는 논리적인 개념으로, EntityManager를 통해 접근


#### 엔티티의 생명주기
***
- 비영속(new/transient): 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
    * 객체를 생성한 상태
    * ```
      Member member = new Member();
      member.setId("member1");
      member.setUsername("회원1");
      ```
- 영속(managed): 영속성 컨텍스트에 관리되는 상태
    * 객체를 저장한 상태
    * ```em.persist(member);```
- 준영속(detached): 영속성 컨텍스트에 저장되었다가 분리된 상태
    * ```em.detach(member);```
- 삭제(removed): 삭제된 상태
    * ```em.remove(member);```

#### 영속성 컨텍스트의 이점
***
- 1차 캐시
    * 조회 시 먼저 데이터베이스가 아닌 1차 캐시에서 조회
    * 1차 캐시로 반복 가능한 읽기 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공
- 동일성 보장
- 트랜잭션을 지원하는 쓰기 지연
    * 트랜잭션을 커밋할 때 한번에 DB에 전달
- 변경 감지
    * 수정 시 setAge(10)를 하면 update와 같은 메서드 없이 변경을 감지하여 트랜잭션을 커밋할 때 수정해줌
- 지연 로딩

#### 플러시?
***
- 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것
- 영속성 컨텍스트 내용을 비우는 것이 아님
- 변경 감지 / 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 / 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 시 발생
- em.flush(): 직접 호출
- 트랜잭션 커밋: 플러시 자동 호출
- JPQL 쿼리 실행: 플러시 자동 호출

#### JPQL 쿼리 실행 시 플러시가 자동으로 호출되는 이유?
***
- 플러시 모드 옵션이 기본값으로 커밋이나 쿼리를 실행할 때 플러시하는 것으로 설정되어 있음(```FlushModeType.AUTO```)
- 커밋할 때만 플러시 하는 ```FlushModeType.COMMIT``` 옵션도 있으나 원래 기본값으로 설정해두는 것이 좋음

#### 준영속 상태로 만드는 방법
***
- ```em.detach(entity)```: 특정 엔티티만 준영속 상태로 전환
- ```em.clear()```: 영속성 컨텍스트를 완전히 초기화
- ```em.close()```: 영속성 컨텍스트를 종료