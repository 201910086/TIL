[실전 스프링 부트와 JPA 활용 2 - API 개발과 성능 최적화](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94)을 수강하며 간단히 정리한 내용이다.

### 권장 순서
***
1. 엔티티 조회 방식으로 우선 접근
    * 페치조인으로 쿼리 수를 최적화
    * 컬렉션 최적화: 페이징 필요-BatchSize로 최적화 / 페이징 필요x-패치조인 사용
2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplate

- 참고: 엔티티 조회 방식은 페치 조인이나, hibernate.default_batch_fetch_size , @BatchSize 같이
코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다. 반면에 DTO를
직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.

### DTO 조회 방식의 선택지
***
- DTO로 조회하는 방법도 각각 장단점이 있음.
- V4는 코드가 단순. 특정 주문 한 건만 조회 시 이 방식을 사용해도 성능이 잘 나옴.
- V5는 코드가 복잡. 여러 주문을 한꺼번에 조회 시 V4 대신 이것을 최적화한 V5 방식을 사용해야 함.
- V6는 완전히 다른 접근 방식. 쿼리 한번으로 최적화되어서 상당히 좋아보이지만 Order를 기준으로 페이징이 불가능. 그리고 데이터가 많으면 중복 전송이 가능해서 V5와 비교해서 성능 차이도 미비함.

### OSIV와 성능 최적화
***
- Open Session In View: 하이버네이트
- Open EntityManager In View: JPA(관례상 OSIV라 한다.)

#### OSIV ON
- ```spring.jpa.open-in-view : true``` 기본값
- OSIV 전략은 트랜잭션 시작처럼 최초 데이터베이스 커넥션 시작 시점부터 API 응답이 끝날 때 까지 영속성 컨텍스트와 데이터베이스 커넥션을 유지
- 그래서 지금까지 View Template이나 API 컨트롤러에서 지연 로딩이 가능했던 것
- 지연 로딩은 영속성 컨텍스트가 살아있어야 가능하고, 영속성 컨텍스트는 기본적으로 데이터베이스 커넥션을 유지. 이것 자체가 큰 장점
- 그런데 이 전략은 너무 오랜시간동안 데이터베이스 커넥션 리소스를 사용하기 때문에 실시간 트래픽이 중요한 애플리케이션에서는 커넥션이 모자랄 수 있음. 결국 장애로 이어짐

#### OSIV OFF
- ```spring.jpa.open-in-view: false``` OSIV 종료
- OSIV를 끄면 트랜잭션을 종료할 때 영속성 컨텍스트를 닫고, 데이터베이스 커넥션도 반환
- -> 커넥션 리소스를 낭비하지 않음
- OSIV를 끄면 모든 지연로딩을 트랜잭션 안에서 처리해야 함. 따라서 지금까지 작성한 많은 지연로딩 코드를 트랜잭션 안으로 넣어야 하는 단점 있음
- 그리고 view template에서 지연로딩이 동작하지 않음. 결론적으로 트랜잭션이 끝나기 전에 지연로딩을 강제로 호출해두어야 함

#### 커멘드와 쿼리 분리
- 실무에서 OSIV를 끈 상태로 복잡성을 관리하는 좋은 방법이 있음 -> Command와 Query를 분리하는 것
- 보통 비즈니스 로직은 특정 엔티티 몇개를 등록하거나 수정하는 것이므로 성능이 크게 문제가 되지 않음
- 그러나 복잡한 화면을 출력하기 위한 쿼리는 화면에 맞추어 성능을 최적화하는 것이 중요. 하지만 그 복잡성에 비해 핵심 비즈니스에 큰 영향을 주는 것은 아님
- 그래서 크고 복잡한 애플리케이션 개발한다면 이 둘의 관심사를 명확하게 분리하는 선택은 유지보수 관점에서 충분히 의미o
- ex.
    * OrderService
    * OrderService: 핵심 비즈니스 로직
    * OrderQueryService: 화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션)
    * 보통 서비스 계층에서 트랜잭션 유지. 두 서비스 모두 트랜잭션을 유지하면서 지연로딩을 사용할 수 있음
- 참고: 고객 서비스의 실시간 API는 OSIV를 끄고 ADMIN처럼 커넥션을 많이 사용하지 않는 곳에서는 OSIV를 켬